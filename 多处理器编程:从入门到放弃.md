# 多处理器编程  


## 并发(Concurrency)
  并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行  
  * 操作系统是最早的并发程序之一
  * 并发控制算法最早在操作系统中研究
  * 操作系统可以同时加载多个程序（进程）  
  * 进程的属性  
  &emsp; * 每个进程都有独立的地址空间，互相不会干扰  
  &emsp;&emsp; - **思考题：即使是拥有root权限的进程，也不能直接访问操作系统的内核的内存，为什么？**  
  &emsp; * 每隔一段时间，就切换到另一个进程执行（看起来进程好像在同时运行——）  
  * 并发行的来源：**进程会调用操作系统的API** -> 防止调用某个大耗时API时，系统卡死，无法运行其他内容。  
  * 典型的并发系统  
        | 处理器数量        | 共享内存    |  并发/并行  |
    | --------   | :-----   | :---- |
    | 单处理器        | 共享内存      |    并发不并行    |
    | 多处理器        | 共享内存      |   并发，并行    |
    | 多处理器        | 不共享内存      |   并发并行    |
 ## 多处理器编程: 入门
  线程:多个执行流并发/并行执行，并且他们共享内存  
  * 两个执行流共享代码（函数)和所有全局变量（数据和堆区）  
  * 两个线程之间的执行顺序是不确定的  
  * 寄存器与堆栈是独享的  

POSIX为我们提供了线程库  
  * pthread_create 创建并运行线程
  * pthread_join 等待某个线程结束
  * man 7 pthreads  
  
  threads.h：线程API的封装
  * create(fn)  
  &emsp; * 创建并运行一个线程，该线程立即开始执行函数fn  
  &emsp; * 函数原型void fn(int tid){ ... }  
  &emsp; * tid是从1开始编号  
  * join(fn)  
  &emsp; * 等待所有线程执行结束  
  &emsp; * 执行函数fn   
  &emsp; * 只能join一次   
  
  threads.h 数据结构（结构体）  
  * 线程以一个单链表的形式进行存储，最新的进程在单链表的头

  一些问题 
  * 如何相信真的启动了多个线程  
  * 如何知道每个线程的堆栈范围和大小  
  &emsp; * 每个线程都要分配8MB堆栈，为什么一千个线程没有耗尽内存（只是在线程中进程标记，并没有实际使用这么多）  
  &emsp; * 使用pmap可以查看到8MB的内存映射区域和4KB的guard  
  

> gcc a.c -I. -lpthread (查找当前目录下的文件并链接文件里的-lpthread)  
> ldd a.out 可以列出文件执行所需要的库函数  
> static int x = 0, 在局部定义也是全局函数  
> ./a.out & 后台运行并给出进程号  
> pmap 进程号 （查看每个线程的信息） 
