## 有限状态机
 ### 1.用有向图来表示有限状态机
 **有向图G**  
 --> 节点是状态， 边是状态的转换， 边的权值是某个动作    
 ### 2.程序 = 有限状态机
 * 程序执行时，状态是有限的  
 &emsp; - 寄存器  
 &emsp; - 内存，数据，堆栈
 * 确定指令得到确定状态
 ---
 所有我们提出问题？
 * 如果程序是deterministic的，那我们的程序无论运行多少次，不都只有唯一的结果了吗？
 * 为了满足我们人机交互的需求，我们需要程序有多个后续状态。不确定的指令可能有多个后续状态。
 ---
 ### 3.实例探讨
 例: (时间)rdtsc  
 -获取处理器的“时间戳”用于精确定时    
 例:（机器状态）rdrand   
 -获取处理器自身提供的“真”随机数指令   
 例:（系统调用）syscall   
 - 一般应用不确定的来源  
 - read(fd, buf, size)  
 &emsp;> 返回值不确定（-1，0，1，2...）   
 &emsp;> buf中数据不确定（例如从键盘输入）  
 
**对于无限的状态，进行取模操作使得无限变成有限**  
**不确定的来源： 程序运行在操作系统/计算机硬件上，他们有自己的状态**  

### 4.X86-64的例子  
  运行在RIng3（低级特权）的应用程序  
  * 通用寄存器16个  
  * PC指针/机器状态寄存器  
  * 内存  
    * 操作系统分配，通过procfs查看
**我们可以使用gdb程序查看进程的寄存器信息和内存信息**

### 5.状态机模型的应用
1.计算机应用的实现：高性能处理器 -> 超标量处理器  
2.计算机系统的应用：程序分析技术
* 静态分析: 根据程序代码推导处状态机的性质   
* 动态分析: 检查运行时观测到状态机的运行  
**我们能否延时间倒推导？**
记录所有Si的开销太大（si由内存+寄存器组成）但一条指令的Side-effect通常有限。故我们可以只记录初始状态，和每条指令前后状态的diff.
(1)Time-Travel Debugging(gdb调试倒退功能)
* target record-full-开始记录
* target stop - 结束从记录
* reverse - step/reverse - stepi - 时间旅行调试
（2）Reverse & Replay  
- 确定指令- 记录初始状态 和 执行过的指令  
- 不确定指令 - 记录初始状态 和 效果 

### 6.理解并发程序的执行 
 PeterSon算法 -> 错误的永远不会执行，正确的一定会执行，不会出现死循环 
 
 
> info inferiors 查看进程的进程号
>/proc/[pid]/maps 会有内存映射信息文件(pid是进程号，maps是个文件， 可以用cat查看) 
>
