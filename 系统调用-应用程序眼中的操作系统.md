# 操作系统 之 应用程序眼中的操作系统  
  ## 1. 什么是应用程序  
  **可执行文件（程序的二进制代码和数据） 和其他数据文件**  
  - linux支持多种可执行文件格式
  - ELF(Executable Linkable Format)是其中最常用的
  ---
  **运行的程序称为进（正在运行）程（程序）**
   - 操作系统中有很多进程对象
   - 在运行时，进程会  
   &emsp; - 在CPU上执行，进行计算  
   &emsp; - 使用操作系统API访问操作系统中的其他对象  
  ---
  **系统中常见的应用程序**  
  - bash, apt, ssh, vim, Packages  
  &emsp; - 这些工具远离并不复杂，例如apt只是把文件复制到指定位置，有时会执行脚本呢/trigger  
  &emsp; - Ubuntu Packages 支持文件名检索
  
  
> 于是我们思考 ELF文件是什么？有什么用？如何得到
## 2. 我们来谈谈ELF二进制文件  
**一个储存在文件系统的上的字节序列**  
- vim/ vi 用vim编辑器打开文件， /bin/ls 打开bin目录下的ls文件，xxd (path/文件) | less 将文件内容一二进制形式给出  
- readelf是专门解析ELF可执行文件的工具  
&emsp; - 我们主要关注ELF文件的header，header包含了文件内容分布，指令集体系结构，入口地址等内容。header决定了ELF应该怎样被加载器加载执行
&emsp; - 我们用 readelf -h /bin/ls 来看看ls文件的header  

>所以应用程序怎样调用操作系统？

## 3.应用程序的实例尝试  
### 我们希望在实现一个最小的应用程序 hello world
```
int main(){
  printf("hello world\n");
}
```
于是我们  
```
gcc -c hello.c #在gcc中编译.c文件使其转换为可重定位文件
ld hello.0 # 链接hello.o文件
./ hello.out # ELF文件的后缀为out
```
失败了,提示我们缺少puts函数引用，链接器提示我们无法找到符号表的_start;  
有趣的是，编译器在这里将高级语言转换为汇编语言时已经进行了一定程度的代码优化，并不是完全将代码优化交给了汇编器去执行。编译器检测到printf函数中输出了固定字符串，为了避免printf函数使用中一些奇怪的
输出检查，将其改为了puts函数。接着，我们试着加入上文代码中缺少的stdio.h库
```
  ld -e ,ain
又失败了，提示segmentation fault，为什么????

> file hi.out 可以查看一些文件的属性，权限
> objdump -d hi.o 更好的查看二进制文本中的内容
> man (指令):用来在手册中查询指令的相关信息
> eg: man readelf 
